
---------------------------------------------------------------------------------------------------------------------------------------------
一般操作
git -v			查看git版本
git status			查看git仓库的状态
git status	-s		查看git仓库的状态,简写模式
git ls-files			查看暂存区的所有文件名
git config --global --list	查看配置信息（包括上面的用户名和邮箱）
alias <别名>="...."		设置命令的别名（这样不用输一大行指令了）

---------------------------------------------------------------------------------------------------------------------------------------------
用户配置：
git config --global user.name "Your name"	配置用户名，设置用户名为Your name
	--global 表示全局配置，对所有仓库都生效
	--system 表示系统配置，对所有用户生效
	如果没有 表示本地配置，只对本地仓库生效
git config --global user.email "1234@qq.com"	配置邮箱，设置邮箱为1234@qq.com(此邮箱并不一定要有效)
	同理--global --system 或为空
git config --global credential.helper		保持用户名和密码？
git config --global --list			查看配置信息（包括上面的用户名和邮箱）


---------------------------------------------------------------------------------------------------------------------------------------------
建立仓库：
git init		在当前目录下建立仓库
git init XXX		在当前目录下生成一个XXX的文件夹并在里面生成一个git仓库
git clone https://....	从网址处克隆一个git仓库到本地的

流程：
对于一个新的文件：
	未跟踪--"git add"-->暂存区--"git commit"-->仓库
对于一个已经在仓库的文件：
	未修改--"修改"-->已修改--"git checkout"-->未修改（相当于更新了修改的内容）
	未修改--"git rm"-->未跟踪（相当于在仓库中的文件去掉了）
对于一个已经在暂存区的文件：
	暂存区--"git rm --cached"-->未跟踪（相当于把暂存区的文件去掉了）
所谓的工作区，暂存区，和仓库相当于三个不同的区域
	当工作区的文件添加到暂存区后，相当于复制了一份到暂存区。同理暂存区添加到仓库也是复制。


---------------------------------------------------------------------------------------------------------------------------------------------
常见的提交命令；
git add 文件名			将该文件添加到暂存区
git commit -m "message"		将所有的暂存区文件放到仓库中去（并附带信息）
	commit只会将暂存区的文件放到仓库中，不会将未跟踪的文件放到仓库中去
git commit -a -m "message"		暂存并提交（可以省略成-am）
git status			查看当前目录下的git仓库的状态
git log				查看当前目录下的git仓库的提交日志
git log --oneline		同上，但只显示一行（更简洁，只显示id和信息）

	
---------------------------------------------------------------------------------------------------------------------------------------------
版本回溯：
git status		查看当前的暂存文件和未跟踪文件
git ls-files		查看暂存区的文件
git reset id			将仓库中的文件回溯到对应id的版本，而对工作区（未跟踪）和暂存区要根据不同的指令来决定
git reset --hard id		将仓库中的文件回溯到对应id的版本，将当前暂存区和工作区也会回到当时版本的状态
git reset --soft id		将仓库中的文件回溯到对应id的版本，保留当前的工作区和暂存区内容
git reset --mixed id		将仓库中的文件回溯到对应id的版本，保留当前的工作区内容，将暂存区回复到当时版本的状态
实例详解：
修改了文件 没add更没commit
	但是要撤回修改（即本地文件回退）
		git checkout <changed_file>或使用 git restore <changed_files>
修改了文件且add到了暂存区 没有commit
	要撤销add操作，但本地文件不变
		git reset <changed_file>或使用 git restore --stage <changed files>
	要撤销add操作，并使本地文件回退
		git checkout HEAD <changed_file>
修改了文件且add并commit了
	要撤销commit，但add和本地文件不变
		git reset --soft HEAD~1
	要撤销add和commit，但本地文件不变
		git reset --mixed HEAD~1 或 git reset HEAD~1
	要撤销add和commit，且本地文件回退
		git reset --hard HEAD~1
特殊：
	通过增加特殊的commit来反向退回版本：
		git revert HEAD或 git revert 70a0f311...


---------------------------------------------------------------------------------------------------------------------------------------------
检查文件差异：
git diff		比较工作区中已修改但未添加到暂存区的文件的差异
		一般用于修改文件后检查修改的内容
git diff HEAD		比较工作区和版本库之间的差异
git diff --cached		比较暂存区和版本库之间的差异
git diff ...... ......		通过版本id查看两个版本之间的差异(或使用分支名查看分支之间的差异)
git diff ...... ...... <file>	查看两个特定版本间的某个特定文件的差异
	git diff HEAD ....		查看最新版本和某个版本之间的差异
	git diff HEAD HEAD~	查看最新版本和前一个版本之间的差异
	git diff HEAD HEAD~3	查看最新版本和前第三个版本之间的差异
下面是git diff的显示内容：
修改的文件：	
	diff --git a/sta2.txt b/sta2.txt 	（显示修改的文件为sta2.txt）
	index 4c13393..611fdbe 100644 （显示文件的哈希值为：旧4c13393 新611fdbe 文件的权限为：100644）
	--- a/sta2.txt
	+++ b/sta2.txt
	@@ -1 +1 @@
	-2222222222 	（表示暂存区中的这一行代码删除了）
	+2222222223 	（表示工作区中多添加了这一行代码）
新添加的文件：
	diff --git a/sta4.txt b/sta4.txt
	new file mode 100644	（表示新文件 权限为100644）
	index 0000000..1ff87c4	（文件的哈希值为：旧0000000 新1ff87c4）
	--- /dev/null	（表示版本库没有这个文件）
	+++ b/sta4.txt	（添加了新文件sta4.txt）
	@@ -0,0 +1 @@
	+444444444444444	（新文件中的内容）


---------------------------------------------------------------------------------------------------------------------------------------------
在版本库中删除文件
git rm <file>		在工作区(本地磁盘)和暂存区中删除文件
			配合git commit可以删除版本库中的文件
git rm --cached <file>	删除暂存区中的文件
git rm -r *			递归删除某个目录下的所有子目录和文件
另一种删除方法(不使用git rm)
	1,删除本地磁盘中的文件,例如:file.txt
	2,使用git add file.txt指令(没错这里是add)告知暂存区这个文件删除了
	3,使用git commit指令生成新版本同时也删除了版本库中的文件


---------------------------------------------------------------------------------------------------------------------------------------------
忽略文件.gitignore
有些时候我们需要git仓库忽略一些文件(比如说一些临时文件/不需要版本控制大文件/用户信息文件)
这样我们可以添加一个.gitignore文件(该文件使用utf8格式),在该文件中写入要忽略的文件名
例如:
/fileA.txt		忽略根目录下fileA.txt文件
/folder/fileA.txt	忽略/folder/目录下fileA.txt文件
folder/fileA.txt	同上
fileA.txt		忽略所有叫fileA.txt的文件(包括在文件夹中的,子文件夹中的同名文件)

/test/		忽略根目录下test文件夹中的所有文件(包括子文件夹和其内容)
/programs/test/		忽略/programs/目录下test文件夹中的所有文件
/programs/**/test/		忽略/programs/目录及其子文件夹下所有的名叫test文件夹中的所有文件
test/		忽略所有叫test的文件夹中的所有文件

/*.o		忽略根目录下所有.o结尾的文件
*.o		忽略所有.o结尾的文件(包括在文件夹中的,子文件夹中的类似文件)
/folder2/*.jpg	忽略/folder2/目录中所有.jpg结尾的文件(不包括子文件夹中的)
		这一条不会忽略folder2/fold/a.jpg文件,因为他不在folder2/这个目录下
/folder2/**/*.jpg	忽略/folder2/目录中所有.jpg结尾的文件(包括子文件夹中的)
img*		忽略所有img开头的文件或文件夹

 
---------------------------------------------------------------------------------------------------------------------------------------------
git工作流程
	1.git clone // 到本地
	2.git checkout -b xxx 切换至新分支xxx
	（相当于复制了remote的仓库到本地的xxx分支上
	3.修改或者添加本地代码（部署在硬盘的源文件上）
	4.git diff 查看自己对代码做出的改变
	5.git add 上传更新后的代码至暂存区
	6.git commit 可以将暂存区里更新后的代码更新到本地git
	7.git push origin xxx 将本地的xxxgit分支上传至github上的git
	----------------------------------------------------------------
	（如果在写自己的代码过程中发现远端GitHub上代码出现改变）
	1.git checkout main 切换回main分支
	2.git pull origin master(main) 将远端修改过的代码再更新到本地
	3.git checkout xxx 回到xxx分支
	4.git rebase main 我在xxx分支上，先把main移过来，然后根据我的commit来修改成新的内容
	（中途可能会出现，rebase conflict -----》手动选择保留哪段代码）
	5.git push -f origin xxx 把rebase后并且更新过的代码再push到远端github上
	（-f ---》强行）
	6.原项目主人采用pull request 中的 squash and merge 合并所有不同的commit
	-----------------------------------------------------------------------------------
	远端完成更新后
	1.git branch -d xxx 删除本地的git分支
	2.git pull origin master 再把远端的最新代码拉至本地


---------------------------------------------------------------------------------------------------------------------------------------------
回车和换行
git config --global core.autocrlf true		（自动转换）git在提交的时候把回车CR换行LF 自动变成 换行LF，在检出LF时变成CRLF
git config --global core.autocrlf input		（一半自动转换）git在提交时不转换，在检出时都自动把CRLF转换成LF
git config --global core.autocrlf false		（不自动转换）git在提交和检出时都不做操作


---------------------------------------------------------------------------------------------------------------------------------------------
仓库配置
SSH仓库需要私有密钥和公钥
在本地生成SSH密钥
cd			回到用户根目录
cd .ssh			打开.ssh文件夹
ssh-keygen -t rsa -b 4096	生成ssh密钥，-t表示协议为RSA协议，-b表示大小为4096
			然后输入密钥的文件名称（不要和之前创建的重复，重复的话会覆盖之前的，这会使之前的密钥丢失）
			之后输入密码（我们设置的这个密钥的密码）
设置好后会生成两个文件，打开.pub这个文件复制这个公钥到GitHub上
之后设置在使用github的时候使用这个文件做密钥
vi config			打开.ssh文件夹中的config文件（如果没有就创建），输入以下内容：
			# github
			Host github.com
			HostName github.com
			PreferredAuthentications publickey
			IdentityFile ~/.ssh/密钥文件名称


---------------------------------------------------------------------------------------------------------------------------------------------
远程仓库的添加、查看和拉取
当我们的本地仓库需要上传或要从远程仓库拉取文件，我们需要以下步骤
	git remote add <远程仓库别名> <远程仓库地址>
		添加远程仓库步骤1，设置别名
	git push -u <远程仓库别名> <本地分支名>:<远程分支名>
		添加远程仓库步骤2，-u 将本地仓库和远程仓库关联起来，将本地的某分支推送给远程仓库的某分支
	git remote -v
		查看远程仓库的别名和地址的对应
	git push <远程仓库别名> <本地分支名>:<远程分支名>
		将本地仓库的某分支上传到远程仓库的某分支（若两个分支名相同可以直接写一个）
	git pull <远程仓库别名> <远程分支名>:<本地分支名>
		将远程仓库的某分支拉取到本地仓库的某分支（若两个分支名相同可以直接写一个）
当我们本地没有仓库，想从远程直接克隆下来
	git clone <远程仓库地址>


---------------------------------------------------------------------------------------------------------------------------------------------
解决push pull不成功的问题
由于git仓库的用户信息和本地的用户信息不一致，导致上传问题
	git config --global user.name "git user name"	使用git的用户名
	git config --global user.email "git user email"	使用git的登陆邮箱
	ssh-keygen -t rsa -b 4096 -C "git仓库邮箱" 	（可选）重新生成密钥
测试ssh连接
	ssh -T git@github.com	测试github的ssh连接状态（要输入ssh的密码）
本地host文件没有配置IP地址和主机名的映射关系导致不能DNS解析
	找到host文件C:\Windows\System32\drivers\etc 以管理员身份打开
	添加IP地址和域名的映射，例如：10.0.0.8 www.XXXX.com


---------------------------------------------------------------------------------------------------------------------------------------------
使用VSCode来编辑、管理、拉取、上传仓库
在git bash中输入 code . 命令打开VSCode
（因为之前在git bash中已经设置了关联远程仓库，所以这里用VSCode打开的时候自动读取的这些内容）
	在工作选项卡中编辑文件
	在源代码管理选项卡中将修改添加到暂存区、提交、上传（还可以检查更改的内容）
常见的VSCode快捷键：
	Ctrl+Shift+`	打开命令面板


---------------------------------------------------------------------------------------------------------------------------------------------
分支基础操作
git branch		查看所有的分支名
git branch -M main		将主分支命名为main
git branch <branch name>	建立新的分支，分支名为<branch name>
git switch <branch name>		切换到对应的分支（git版本>2.23版本）
				切换分支命令会影响本地磁盘的文件，比如说某个分支中有不同的新文件，那么切换过去后就会出现该文件
git checkout <branch name>		切换到对应的分支（不建议使用）
				（因为这个指令也可以用于恢复文件，当恢复的文件名和分支名相同时就会产生歧义，默认是切换而不是恢复）
git merge <branch name>		将<branch name>这个分支合并到当前所在的分支中去
				比如之前switch到了main分支，那么就是把<branch name>这个分支合并到main分支中去
git log --graph --oneline --decorate --all	查看分支图
git branch -d <branch name>	删除已经被合并的分支
git branch -D <branch name>	强制删除没有被合并的分支


---------------------------------------------------------------------------------------------------------------------------------------------
分支冲突解决
git merge <branch name>	合并分支
git status			查看冲突的文件名
git diff			查看冲突的内容
使用编辑器在冲突的文件里解决冲突（就是把冲突内容手动修改）
将冲突的文件再次添加到暂存区，并commit提交。提交完成后两个本身有冲突的分支就完成了合并。
git merge --abort		可以中途终止分支的合并


---------------------------------------------------------------------------------------------------------------------------------------------
变基rebase
git switch <branch name1>	切换到要变基的分支
git rebase <branch name2>	将<branch name1>整个移植（变基）到<branch name2>的最新提交处
			即找到1和2的分叉点，从该处把1分支所有提交接驳到2分支的最新提交的后面
			相反如果是switch 2 rebase 1，那就是把2分支接驳到1分支的后面


---------------------------------------------------------------------------------------------------------------------------------------------
变基和分支的优缺点
分支	优点：	不会破坏提交历史，方便回溯查看
	缺点：	产生额外的额提交节点，图比较复杂
变基	优点：	不会增加额外的提交节点，图比较干净
	缺点：	会改变提交历史，尽量避免在公用分支中使用变基操作

